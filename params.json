{"name":"Kino","tagline":"Kino - framework for building Actors networks","body":"[![Build status](https://ci.appveyor.com/api/projects/status/khn5imataa5uw4oj?svg=true)](https://ci.appveyor.com/project/iiwaasnet/kino)\r\n[![NuGet kino.Client](https://badge.fury.io/nu/kino.Client.svg)](http://badge.fury.io/nu/kino.Client)\r\n[![NuGet kino.Actors](https://badge.fury.io/nu/kino.Actors.svg)](http://badge.fury.io/nu/kino.Actors)\r\n[![NuGet kino.Rendezvous](https://badge.fury.io/nu/kino.Rendezvous.svg)](http://badge.fury.io/nu/kino.Rendezvous)\r\n\r\n# Kino - framework for building Actor-like networks\r\n\r\n[![Join the chat at https://gitter.im/iiwaasnet/kino](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/iiwaasnet/kino?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\r\n*(Project is in development)*\r\n\r\n\r\n![Actors](https://cdn.rawgit.com/iiwaasnet/kino/master/img/Actors.png)\r\n\r\n**kino** is an *[Actor] (https://en.wikipedia.org/wiki/Actor_model)-like* framework, built to allow scaling of Actors over the network with low efforts for configuration management. A *kino* **Actor** registers itself by declaring message type(s) it can process. There is no hierarchy of Actors, as well as no logical addresses assigned to them.\r\nActor's message handling method receives one input message and may send one or more output messages, either synchronously or asynchronously. It may produce no output as well.\r\nActors are hosted by an ActorHost.\r\n\r\n\r\n\r\n**ActorHost** receives messages and calls corresponding Actor's handler based on the message type (and version). All Actors, hosted by the same **ActorHost**, share same receiving thread. This means that until previously fetched message is processed by an Actor, the next one will be waiting in the queue. ActorHost is a unit of in-proc scaling.\r\n\r\n![ActorHost](https://cdn.rawgit.com/iiwaasnet/kino/master/img/ActorHost.png)\r\n\r\nEvery ActorHost connects to a MessageRouter.\r\n\r\n\r\n**MessageRouter** is responsible for:\r\n  * registering all Actors, which are hosted by connected ActorHosts;\r\n  * type-based message routing to locally connected Actors;\r\n  * typed-based message routing to external, i.e. out-of-proc Actors, if no locally registered Actors are able to process the message.\r\n\r\n![MessageRouter](https://cdn.rawgit.com/iiwaasnet/kino/master/img/MessageRouter.png)\r\n\r\nIn order to be able to discover other Actors, MessageRouter connects to Rendezvous server.\r\n\r\n\r\n\r\n**Rendezvous** server is a well-known point, where all MessageRouters connect, building up an Actors network. Since Rendezvous server is a single point of failure, it is recommended to start several instances of the service on different nodes to build up a *fault-tolerant cluster*. In this case, MessageRouter should be configured with endpoints of all Rendezvous servers from the cluster. On startup, Rendezvous synod [elects](http://www.xtreemfs.org/publications/flease_paper_ipdps.pdf) a Leader, which than starts to broadcast:\r\n  * MessageRouters' registration messages, announcing which type of messages locally registered Actors are able to process;\r\n  * Ping message, to check nodes availability;\r\n  * Pong response from all the registered nodes to all registered nodes.\r\n\r\nIn case Rendezvous Leader changes, MessageRouter do a round-robin search among all configured endpoints to connect to a new Leader.  Dynamic reconfiguration of Rendezvous cluster is not supported. Nevertheless, the cluster can be stopped. In this case, although Actors will still exchange messages, configuration changes will not be propagated to all nodes of the network.\r\n\r\n![Rendezvous](https://cdn.rawgit.com/iiwaasnet/kino/master/img/Rendezvous.png)\r\n\r\n\r\n**MessageHub** is one of the ways to send messages into Actors network. It is a *starting point of the flow*. First message sent from MessageHub gets CorrelationId assigned, which is then copied to any other message, created during the message flow. It is possible to create a *callback point*, which is defined by message type and caller address. \r\nWhenever an Actor responds with the message, which type corresponds to the one registered in the callback, it is immediately routed back to the address in the callback point.\r\nThus, clients may emulate synchronous calls, waiting for the callback to be resolved. Callback may return back a message or an exception, whatever happens first.\r\n\r\n![Callback](https://cdn.rawgit.com/iiwaasnet/kino/master/img/Callback.png)\r\n\r\n## Example\r\nWe've got a very important task to find out the cities with highest and lowest temperature.\r\n\r\nHow we are going to do that:\r\n  * get list of all cities\r\n  * retrieve current weather for each city from the list\r\n  * collect all weather data and find cities with highest and lowest temperature\r\n  \r\nLet's define logical flow of the messages for this task:\r\n```\r\nIn Message                        Action                                  Out Message\r\n\r\n                                   Send                                -> {List of Cities}\r\n{List of Cities}                -> For each City Send                  -> {Weather Request for a City}\r\n{Weather Request for a City}    -> Get Current Weather for a City      -> [{City Weather}, {Log City Weather}]\r\n{Log City Weather}              -> Log City Weather\r\n{City Weather}                  -> Aggregate City Weather              -> {Cities with Highest and Lowest Temperature}\r\n```\r\n\r\n![pic]( https://cdn.rawgit.com/iiwaasnet/kino/master/img/Weather.png)\r\n\r\nNevertheless, there are some questions to this design:\r\n  * how does **WeatherAggregator** actor group all messages together for each client request?\r\n  * how does it know, when the last message arrives?\r\n  * if we host several instances of **WeatherAggregator** actor, which one will be responsible for grouping up final result?\r\n\r\nThe first problem is solved by using **CorrelationId**, which is generated once for initial message and then copied onto every other message within the same flow. Additionally, in every **CityWeather** message we provide the **Total Number** of all messages to be expected. \r\nNow, we can use combination of **CorrelationId** and **Total Number** properties to aggregate all the messages of current flow.\r\nTo solve the last problem, we use some central storage, where all instances of **CityWeather** actor save intermediate results:\r\n  * what are the currently known highest and lowest temperatures;\r\n  * how many messages from the **Total Number** of expected messages are already processed.\r\n\r\nInstance, which updates the shared storage with the last message of the flow, will send the resulting message for the client.\r\n\r\nNow, some code. \r\n### Client\r\n[WeatherRequestScheduler.cs](https://github.com/iiwaasnet/weather/blob/master/src/weather.stat/Scheduler/WeatherRequestScheduler.cs)\r\n``` csharp\r\n// Read list of cities\r\nvar cities = (await GetCityList()).Select(c => c.Name);\r\n\r\n// Create initial message with CorrelationId assigned to it\r\nvar message = Message.CreateFlowStartMessage(new RequestWeatherHighlightsMessage\r\n                                             {\r\n                                                 Cities = cities\r\n                                             });\r\nmessage.TraceOptions = MessageTraceOptions.Routing;\r\n\r\n// Define callback with result message\r\nvar callback = CallbackPoint.Create<WeatherHighlightsMessage>();\r\n\r\n// Send message into actors network and specify wait timeout\r\nvar promise = messageHub.EnqueueRequest(message, callback, TimeSpan.FromMinutes(1));\r\n\r\n// Wait for result\r\nvar weatherAggregates = (await promise.GetResponse()).GetPayload<WeatherHighlightsMessage>();\r\n\r\n// Print result\r\nWriteLine($\"Lowest T: {weatherAggregates.LowestTemperature.CityName} {weatherAggregates.LowestTemperature.Temperature} C \" +\r\n          $\"Highest T: {weatherAggregates.HighestTemperature.CityName} {weatherAggregates.HighestTemperature.Temperature} C. \");\r\n\r\n```\r\n  \r\n### Sample Message declaration\r\n```csharp\r\n[ProtoContract]\r\npublic class RequestWeatherHighlightsMessage: Payload\r\n{\r\n    private static byte[] MessageIdentity = \"REQWHIGHLT\".GetBytes();\r\n    private static byte[] MessageVersion = \"1.0\".GetBytes();\r\n\r\n    [ProtoMember(1)]\r\n    public IEnumerable<string> Cities { get; set; }\r\n\r\n    public override byte[] Version => MessageVersion;\r\n    public override byte[] Identity => MessageIdentity;\r\n}\r\n```\r\nDefault serializer for all messages, other than Exception, [protobuf-net](https://github.com/mgravell/protobuf-net).\r\n\r\n## Actor\r\nHere is the code for one of the actors, responsible for getting current weather in a city:\r\n```csharp\r\npublic class WeatherCollector : IActor\r\n{\r\n    // Method, which handles RequestCityWeatherMessage message\r\n    [MessageHandlerDefinition(typeof (RequestCityWeatherMessage))]\r\n    private async Task<IActorResult> Handler(IMessage message)\r\n    {\r\n        // Get message payload\r\n        var request = message.GetPayload<RequestCityWeatherMessage>();\r\n        \r\n        // Request weather from external service and wait for result\r\n        var weather = await GetCityWeather(request.CityName);        \r\n        var cityWeather = new CityWeather\r\n                          {\r\n                              CityName = request.CityName,\r\n                              Temperature = weather?.Main?.Temp\r\n                          };\r\n                          \r\n        // Create CityWeatherMessage message with current weather in the city\r\n        // Forward TotalCityCount to the next actor\r\n        var response = Message.Create(new CityWeatherMessage\r\n                                      {\r\n                                          Weather = cityWeather,\r\n                                          TotalCityCount = request.TotalCityCount\r\n                                      });\r\n                                      \r\n        // Create a message to be processed by a logging actor\r\n        var log = Message.Create(new LogCityWeatherMessage\r\n                                 {\r\n                                     Weather = cityWeather\r\n                                 });\r\n                                 \r\n        // Return response messages\r\n        return new ActorResult(response, log);\r\n    }\r\n}\r\n```\r\n\r\nComplete solution for Weather example could be found [here](https://github.com/iiwaasnet/weather).\r\nAnother example, which uses Rendezvous service, could be found in [Samples](https://github.com/iiwaasnet/kino/tree/master/src/Samples) folder.\r\n\r\n\r\n\r\nPowered by **[NetMQ](https://github.com/zeromq/netmq)**\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}