{"name":"Kino","tagline":"Kino - framework for building Actors networks","body":"[![Build status](https://ci.appveyor.com/api/projects/status/khn5imataa5uw4oj?svg=true)](https://ci.appveyor.com/project/iiwaasnet/kino)\r\n[![NuGet version](https://badge.fury.io/nu/kino.svg)](https://badge.fury.io/nu/kino)\r\n[![NuGet version](https://badge.fury.io/nu/kino.Rendezvous.svg)](https://badge.fury.io/nu/kino.Rendezvous)\r\n\r\n# Kino - framework for building Actor-like networks\r\n\r\n[![Join the chat at https://gitter.im/iiwaasnet/kino](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/iiwaasnet/kino?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\r\n*(Project is in development)*\r\n\r\nBuilding a Web service is one of the ways to implement a component, accessible over the network. \r\nFollowing good design principles, we will create reusable, granular and relevant interface for our service. To be able to survive failures,\r\nwe would deploy it redundantly and make it accessible over the load-balancer at some well-known URL.\r\n\r\nBut what if the functionality we would like to expose is too small for a stand-alone service? What if we would like to scale out or extract for better reusability\r\njust some parts of existing service?  At some point we might find ourselves managing dozens of new services, URLs and a lot of network configurations.\r\nThis still might be a proper design choice, but let's try something else...\r\n\r\n**Kino** - is an *[Actor] (https://en.wikipedia.org/wiki/Actor_model)-like* framework for implementing and hosting components,\r\naccessible over the network. In other words, **kino** allows to build *networks* of components.\r\nAlthough, the framework does not implement classical Actor Model, we will still call our components as actors.\r\n\r\nAn **Actor** contains implementation, some methods, which others can invoke by sending corresponding **Message**.\r\nYou don't have to know address of an actor to send a message. The only thing needed - is the message itself. Message **Identity** (or type) and **Version** are used to find concrete actor and \r\ninvoke its method. That's it. You send a message *somewhere* and it is magically routed to a proper actor's method for you.\r\n\r\n\r\n![Actors](https://cdn.rawgit.com/iiwaasnet/kino/master/img/Actors.png)\r\n\r\n\r\nFor this magic to work we need someone, who will create the mapping between messages and actors' methods.\r\nIn **kino** this is done by the **ActorHost**.  During registration ActorHost queries actor's interface, tuples of method and\r\nmessage type, and builds the **ActorHandlerMap** table. This mapping table is then used to find corresponding handling method for each message\r\nfrom the incoming message queue.\r\n\r\n![ActorHost](https://cdn.rawgit.com/iiwaasnet/kino/master/img/ActorHost.png)\r\n\r\n\r\nThis looks good but still far from being a network of actors. We need to scale in terms of number of actors and physical nodes.\r\nWe do it with the help of **MessageRouter**. ActorHost contains registration information, necessary to perform *in-proc* routing\r\nof the messages. MessageRouter, in its turn, makes this registration information available for *out-of-proc* message routing. Let's take a look how this is achieved.\r\n\r\nMessage passing between core **kino** components (ActorHosts, MessageRouters and some others) is done over the **sockets**.\r\nAlong with URL, every *receiving* socket has globally unique socket **Identity** assigned. This socket identity together with message identity and message version\r\nare used for message routing.\r\n\r\n\r\n![MessageRouter](https://cdn.rawgit.com/iiwaasnet/kino/master/img/MessageRouter.png)\r\n\r\n\r\nDuring actor registration process, after ActorHost has added corresponding entries with message identities and method references to ActorHandlerMap table,\r\nit sends the same registration information to MessageRouter, replacing method references with the identity of it's *receiving* socket.\r\nMessageRouter stores this registration into **InternalRoutingTable**. Further on, MessageRouter can connect to other MessageRouter(s) over\r\nthe **scale out socket** (for simplicity, receiving and sending scale out sockets shown as one) and exchange information about the registrations,\r\nthey have in their InternalRoutingTables. But this time, MessageRouter replaces socket identities of ActorHosts with its own identity of the *scale out socket*.\r\nWhen other MessageRouter receives such a registration information, it stores it into it's **ExternalRoutingTable**. This is how in **kino** network everyone knows everything.\r\n\r\nNow, when MessageRouter receives a message, either via local or scale out socket, it looks up by *message identity* it's InternalRoutingTable to find a\r\n*socket identity* of an ActorHost, which is able to process the message. If there is an entry, incoming message is routed to ActorHost socket. \r\nActorHost picks up the message, does a lookup in it's *ActorHandlerMap* for a handling method and passes the message to corresponding actor.\r\n\r\nIf, nevertheless, MessageRouter doesn't find any entry in its InternalRoutingTable, it does a lookup in *ExternalRoutingTable*. The socket identity, if found,\r\nin this case points to another MessageRouter, to which then the message is finally forwarded for processing.\r\n\r\nNow, we know how actors are registered within ActorHosts and how MessageRouters can exchange registrations and forward messages to each other.\r\nLet's take a look how MessageRouters, eventually deployed on different nodes, can find each other in this big world. **kino** provides a **Rendezvous** Service\r\nfor sole MessageRouters. *Rendezvous* Service endpoint is the **single** well-known endpoint, which should be configured on every MessageRouter connected\r\nto the same **kino** network. No need to share or configure any other URLs.\r\n\r\n\r\n![Rendezvous](https://cdn.rawgit.com/iiwaasnet/kino/master/img/Rendezvous.png)\r\n\r\n\r\nRendezvous Service is that glue, which keeps all parts together: it forwards registration information from newly connected routers to all\r\nmembers of the network, sends PINGs and broadcasts PONGs as a part of health check process. Since it's so important, the Rendezvous service\r\nis usually deployed on a *cluster* of servers, so that it can survive hardware failures. Nevertheless, even if the Rendezvous\r\ncluster dies (or stops because of deployment), **kino** network still continues to operate, except that network configuration changes will\r\nnot be propagated until the cluster is online again.\r\n\r\nActor's method, that was invoked by ActorHost to process incoming message, may respond with a new message. This new message will be traveling over the network until\r\nit reaches other actor and so on. If actor can create only a response message, how can we create a request message, i.e. initial one?\r\n**MessageHub** is used to send a message into **kino** network. Depending on your needs, you may send either one-way message,\r\nor specify a *callback point*. To explain what the callback point is, let's talk a bit about message flows.\r\n\r\nWhen we build an application, we try to group relevant code into some components. These components have well-defined interface and responsibilities.\r\nAt high level, code of the application looks like a sequence of calls to some components with expected type of return value.\r\nIf we replace components with actors, which are sending and receiving messages, we may say that we have a message flow, which implements desired behavior\r\nof the application. Return value of expected type - this is a callback point in message flow. When building application with **kino**, we design a message flow,\r\nwhich we expect to finish at some point in time with predefined result - message. So, callback point, is nothing else than identity of the message, which should be routed\r\nback to initiator of the flow, i.e. return value.\r\n\r\nIn nutshell, caller sends initial flow message via MessageHub into **kino** network and defines a callback point. Dozens of new messages may be created during this flow,\r\ntraveling over different nodes, but as soon as somewhere someone create a message with the identity, defined in the callback, this message will be immediately routed\r\nback to the caller. Voila, you've got your return value!\r\n\r\n![Callback](https://cdn.rawgit.com/iiwaasnet/kino/master/img/Callback.png)\r\n\r\n\r\n## Example\r\nWe've got a very important task to find out the cities with highest and lowest temperature.\r\n\r\nHow we are going to do that:\r\n  * get list of all cities\r\n  * retrieve current weather for each city from the list\r\n  * collect all weather data and find cities with highest and lowest temperature\r\n  \r\nLet's define logical flow of the messages for this task:\r\n```\r\nIn Message                        Action                                  Out Message\r\n\r\n                                   Send                                -> {List of Cities}\r\n{List of Cities}                -> For each City Send                  -> {Weather Request for a City}\r\n{Weather Request for a City}    -> Get Current Weather for a City      -> [{City Weather}, {Log City Weather}]\r\n{Log City Weather}              -> Log City Weather\r\n{City Weather}                  -> Aggregate City Weather              -> {Cities with Highest and Lowest Temperature}\r\n```\r\n\r\n![pic]( https://cdn.rawgit.com/iiwaasnet/kino/master/img/Weather.png)\r\n\r\nNevertheless, there are some questions to this design:\r\n  * how does **WeatherAggregator** actor group all messages together for each client request?\r\n  * how does it know, when the last message arrives?\r\n  * if we host several instances of **WeatherAggregator** actor, which one will be responsible for grouping up final result?\r\n\r\nThe first problem is solved by using **CorrelationId**, which is generated once for initial message and then copied onto every other message within the same flow. Additionally, in every **CityWeather** message we provide the **Total Number** of all messages to be expected. \r\nNow, we can use combination of **CorrelationId** and **Total Number** properties to aggregate all the messages of current flow.\r\nTo solve the last problem, we use some central storage, where all instances of **CityWeather** actor save intermediate results:\r\n  * what are the currently known highest and lowest temperatures;\r\n  * how many messages from the **Total Number** of expected messages are already processed.\r\n\r\nInstance, which updates the shared storage with the last message of the flow, will send the resulting message for the client.\r\n\r\nNow, some code. \r\n### Client\r\n[WeatherRequestScheduler.cs](https://github.com/iiwaasnet/weather/blob/master/src/weather.stat/Scheduler/WeatherRequestScheduler.cs)\r\n``` csharp\r\n// Read list of cities\r\nvar cities = (await GetCityList()).Select(c => c.Name);\r\n\r\n// Create initial message with CorrelationId assigned to it\r\nvar message = Message.CreateFlowStartMessage(new RequestWeatherHighlightsMessage\r\n                                             {\r\n                                                 Cities = cities\r\n                                             });\r\nmessage.TraceOptions = MessageTraceOptions.Routing;\r\n\r\n// Define callback with result message\r\nvar callback = CallbackPoint.Create<WeatherHighlightsMessage>();\r\n\r\n// Send message into actors network and specify wait timeout\r\nvar promise = messageHub.EnqueueRequest(message, callback, TimeSpan.FromMinutes(1));\r\n\r\n// Wait for result\r\nvar weatherAggregates = (await promise.GetResponse()).GetPayload<WeatherHighlightsMessage>();\r\n\r\n// Print result\r\nWriteLine($\"Lowest T: {weatherAggregates.LowestTemperature.CityName} {weatherAggregates.LowestTemperature.Temperature} C \" +\r\n          $\"Highest T: {weatherAggregates.HighestTemperature.CityName} {weatherAggregates.HighestTemperature.Temperature} C. \");\r\n\r\n```\r\n  \r\n### Sample Message declaration\r\n```csharp\r\n[ProtoContract]\r\npublic class RequestWeatherHighlightsMessage: Payload\r\n{\r\n    private static byte[] MessageIdentity = \"REQWHIGHLT\".GetBytes();\r\n    private static byte[] MessageVersion = \"1.0\".GetBytes();\r\n\r\n    [ProtoMember(1)]\r\n    public IEnumerable<string> Cities { get; set; }\r\n\r\n    public override byte[] Version => MessageVersion;\r\n    public override byte[] Identity => MessageIdentity;\r\n}\r\n```\r\nDefault serializer for all messages, other than Exception, [protobuf-net](https://github.com/mgravell/protobuf-net).\r\n\r\n## Actor\r\nHere is the code for one of the actors, responsible for getting current weather in a city:\r\n```csharp\r\npublic class WeatherCollector : IActor\r\n{\r\n    // Method, which handles RequestCityWeatherMessage message\r\n    [MessageHandlerDefinition(typeof (RequestCityWeatherMessage))]\r\n    private async Task<IActorResult> Handler(IMessage message)\r\n    {\r\n        // Get message payload\r\n        var request = message.GetPayload<RequestCityWeatherMessage>();\r\n        \r\n        // Request weather from external service and wait for result\r\n        var weather = await GetCityWeather(request.CityName);        \r\n        var cityWeather = new CityWeather\r\n                          {\r\n                              CityName = request.CityName,\r\n                              Temperature = weather?.Main?.Temp\r\n                          };\r\n                          \r\n        // Create CityWeatherMessage message with current weather in the city\r\n        // Forward TotalCityCount to the next actor\r\n        var response = Message.Create(new CityWeatherMessage\r\n                                      {\r\n                                          Weather = cityWeather,\r\n                                          TotalCityCount = request.TotalCityCount\r\n                                      });\r\n                                      \r\n        // Create a message to be processed by a logging actor\r\n        var log = Message.Create(new LogCityWeatherMessage\r\n                                 {\r\n                                     Weather = cityWeather\r\n                                 });\r\n                                 \r\n        // Return response messages\r\n        return new ActorResult(response, log);\r\n    }\r\n}\r\n```\r\n\r\nComplete solution for Weather example could be found [here](https://github.com/iiwaasnet/weather).\r\nAnother example, which uses Rendezvous service, could be found in [Samples](https://github.com/iiwaasnet/kino/tree/master/src/Samples) folder.\r\n\r\n\r\n\r\nPowered by **[NetMQ](https://github.com/zeromq/netmq)**\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}