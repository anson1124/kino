<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Kino by iiwaasnet</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Kino</h1>
      <h2 class="project-tagline">Kino - framework for building Actors networks</h2>
      <a href="https://github.com/iiwaasnet/kino" class="btn">View on GitHub</a>
      <a href="https://github.com/iiwaasnet/kino/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/iiwaasnet/kino/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <p><a href="https://ci.appveyor.com/project/iiwaasnet/kino"><img src="https://ci.appveyor.com/api/projects/status/khn5imataa5uw4oj?svg=true" alt="Build status"></a>
<a href="https://badge.fury.io/nu/kino"><img src="https://badge.fury.io/nu/kino.svg" alt="NuGet version"></a>
<a href="https://badge.fury.io/nu/kino.Rendezvous"><img src="https://badge.fury.io/nu/kino.Rendezvous.svg" alt="NuGet version"></a></p>

<h1>
<a id="kino---framework-for-building-actor-like-networks" class="anchor" href="#kino---framework-for-building-actor-like-networks" aria-hidden="true"><span class="octicon octicon-link"></span></a>Kino - framework for building Actor-like networks</h1>

<p><a href="https://gitter.im/iiwaasnet/kino?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge"><img src="https://badges.gitter.im/Join%20Chat.svg" alt="Join the chat at https://gitter.im/iiwaasnet/kino"></a>
<em>(Project is in development)</em></p>

<p>Building a Web service is one of the ways to implement a component, accessible over the network. 
Following good design principles, we will create reusable, granular and relevant interface for our service. To be able to survive failures,
we would deploy it redundantly and make it accessible over the load-balancer at some well-known URL.</p>

<p>But what if the functionality we would like to expose is too small for a stand-alone service? What if we would like to scale out or extract for better reusability
just some parts of existing service?  At some point we might find ourselves managing dozens of new services, URLs and a lot of network configurations.
This still might be a proper design choice, but let's try something else...</p>

<p><strong>Kino</strong> - is an <em><a href="https://en.wikipedia.org/wiki/Actor_model">Actor</a>-like</em> framework for implementing and hosting components,
accessible over the network. In other words, <strong>kino</strong> allows to build <em>networks</em> of components.
Although, the framework does not implement classical Actor Model, we will still call our components as actors.</p>

<p>An <strong>Actor</strong> contains implementation, some methods, which others can invoke by sending corresponding <strong>Message</strong>.
You don't have to know address of an actor to send a message. The only thing needed - is the message itself. Message <strong>Identity</strong> (or type) and <strong>Version</strong> are used to find concrete actor and 
invoke its method. That's it. You send a message <em>somewhere</em> and it is magically routed to a proper actor's method for you.</p>

<p><img src="https://cdn.rawgit.com/iiwaasnet/kino/master/img/Actors.png" alt="Actors"></p>

<p>For this magic to work we need someone, who will create the mapping between messages and actors' methods.
In <strong>kino</strong> this is done by the <strong>ActorHost</strong>.  During registration ActorHost queries actor's interface, tuples of method and
message type, and builds the <strong>ActorHandlerMap</strong> table. This mapping table is then used to find corresponding handling method for each message
from the incoming message queue.</p>

<p><img src="https://cdn.rawgit.com/iiwaasnet/kino/master/img/ActorHost.png" alt="ActorHost"></p>

<p>This looks good but still far from being a network of actors. We need to scale in terms of number of actors and physical nodes.
We do it with the help of <strong>MessageRouter</strong>. ActorHost contains registration information, necessary to perform <em>in-proc</em> routing
of the messages. MessageRouter, in its turn, makes this registration information available for <em>out-of-proc</em> message routing. Let's take a look how this is achieved.</p>

<p>Message passing between core <strong>kino</strong> components (ActorHosts, MessageRouters and some others) is done over the <strong>sockets</strong>.
Along with URL, every <em>receiving</em> socket has globally unique socket <strong>Identity</strong> assigned. This socket identity together with message identity and message version
are used for message routing.</p>

<p><img src="https://cdn.rawgit.com/iiwaasnet/kino/master/img/MessageRouter.png" alt="MessageRouter"></p>

<p>During actor registration process, after ActorHost has added corresponding entries with message identities and method references to ActorHandlerMap table,
it sends the same registration information to MessageRouter, replacing method references with the identity of it's <em>receiving</em> socket.
MessageRouter stores this registration into <strong>InternalRoutingTable</strong>. Further on, MessageRouter can connect to other MessageRouter(s) over
the <strong>scale out socket</strong> (for simplicity, receiving and sending scale out sockets shown as one) and exchange information about the registrations,
they have in their InternalRoutingTables. But this time, MessageRouter replaces socket identities of ActorHosts with its own identity of the <em>scale out socket</em>.
When other MessageRouter receives such a registration information, it stores it into it's <strong>ExternalRoutingTable</strong>. This is how in <strong>kino</strong> network everyone knows everything.</p>

<p>Now, when MessageRouter receives a message, either via local or scale out socket, it looks up by <em>message identity</em> it's InternalRoutingTable to find a
<em>socket identity</em> of an ActorHost, which is able to process the message. If there is an entry, incoming message is routed to ActorHost socket. 
ActorHost picks up the message, does a lookup in it's <em>ActorHandlerMap</em> for a handling method and passes the message to corresponding actor.</p>

<p>If, nevertheless, MessageRouter doesn't find any entry in its InternalRoutingTable, it does a lookup in <em>ExternalRoutingTable</em>. The socket identity, if found,
in this case points to another MessageRouter, to which then the message is finally forwarded for processing.</p>

<p>Now, we know how actors are registered within ActorHosts and how MessageRouters can exchange registrations and forward messages to each other.
Let's take a look how MessageRouters, eventually deployed on different nodes, can find each other in this big world. <strong>kino</strong> provides a <strong>Rendezvous</strong> Service
for sole MessageRouters. <em>Rendezvous</em> Service endpoint is the <strong>single</strong> well-known endpoint, which should be configured on every MessageRouter connected
to the same <strong>kino</strong> network. No need to share or configure any other URLs.</p>

<p><img src="https://cdn.rawgit.com/iiwaasnet/kino/master/img/Rendezvous.png" alt="Rendezvous"></p>

<p>Rendezvous Service is that glue, which keeps all parts together: it forwards registration information from newly connected routers to all
members of the network, sends PINGs and broadcasts PONGs as a part of health check process. Since it's so important, the Rendezvous service
is usually deployed on a <em>cluster</em> of servers, so that it can survive hardware failures. Nevertheless, even if the Rendezvous
cluster dies (or stops because of deployment), <strong>kino</strong> network still continues to operate, except that network configuration changes will
not be propagated until the cluster is online again.</p>

<p>Actor's method, that was invoked by ActorHost to process incoming message, may respond with a new message. This new message will be traveling over the network until
it reaches other actor and so on. If actor can create only a response message, how can we create a request message, i.e. initial one?
<strong>MessageHub</strong> is used to send a message into <strong>kino</strong> network. Depending on your needs, you may send either one-way message,
or specify a <em>callback point</em>. To explain what the callback point is, let's talk a bit about message flows.</p>

<p>When we build an application, we try to group relevant code into some components. These components have well-defined interface and responsibilities.
At high level, code of the application looks like a sequence of calls to some components with expected type of return value.
If we replace components with actors, which are sending and receiving messages, we may say that we have a message flow, which implements desired behavior
of the application. Return value of expected type - this is a callback point in message flow. When building application with <strong>kino</strong>, we design a message flow,
which we expect to finish at some point in time with predefined result - message. So, callback point, is nothing else than identity of the message, which should be routed
back to initiator of the flow, i.e. return value.</p>

<p>In nutshell, caller sends initial flow message via MessageHub into <strong>kino</strong> network and defines a callback point. Dozens of new messages may be created during this flow,
traveling over different nodes, but as soon as somewhere someone create a message with the identity, defined in the callback, this message will be immediately routed
back to the caller. Voila, you've got your return value!</p>

<p><img src="https://cdn.rawgit.com/iiwaasnet/kino/master/img/Callback.png" alt="Callback"></p>

<h2>
<a id="example" class="anchor" href="#example" aria-hidden="true"><span class="octicon octicon-link"></span></a>Example</h2>

<p>We've got a very important task to find out the cities with highest and lowest temperature.</p>

<p>How we are going to do that:</p>

<ul>
<li>get list of all cities</li>
<li>retrieve current weather for each city from the list</li>
<li>collect all weather data and find cities with highest and lowest temperature</li>
</ul>

<p>Let's define logical flow of the messages for this task:</p>

<pre><code>In Message                        Action                                  Out Message

                                   Send                                -&gt; {List of Cities}
{List of Cities}                -&gt; For each City Send                  -&gt; {Weather Request for a City}
{Weather Request for a City}    -&gt; Get Current Weather for a City      -&gt; [{City Weather}, {Log City Weather}]
{Log City Weather}              -&gt; Log City Weather
{City Weather}                  -&gt; Aggregate City Weather              -&gt; {Cities with Highest and Lowest Temperature}
</code></pre>

<p><img src="https://cdn.rawgit.com/iiwaasnet/kino/master/img/Weather.png" alt="pic"></p>

<p>Nevertheless, there are some questions to this design:</p>

<ul>
<li>how does <strong>WeatherAggregator</strong> actor group all messages together for each client request?</li>
<li>how does it know, when the last message arrives?</li>
<li>if we host several instances of <strong>WeatherAggregator</strong> actor, which one will be responsible for grouping up final result?</li>
</ul>

<p>The first problem is solved by using <strong>CorrelationId</strong>, which is generated once for initial message and then copied onto every other message within the same flow. Additionally, in every <strong>CityWeather</strong> message we provide the <strong>Total Number</strong> of all messages to be expected. 
Now, we can use combination of <strong>CorrelationId</strong> and <strong>Total Number</strong> properties to aggregate all the messages of current flow.
To solve the last problem, we use some central storage, where all instances of <strong>CityWeather</strong> actor save intermediate results:</p>

<ul>
<li>what are the currently known highest and lowest temperatures;</li>
<li>how many messages from the <strong>Total Number</strong> of expected messages are already processed.</li>
</ul>

<p>Instance, which updates the shared storage with the last message of the flow, will send the resulting message for the client.</p>

<p>Now, some code. </p>

<h3>
<a id="client" class="anchor" href="#client" aria-hidden="true"><span class="octicon octicon-link"></span></a>Client</h3>

<p><a href="https://github.com/iiwaasnet/weather/blob/master/src/weather.stat/Scheduler/WeatherRequestScheduler.cs">WeatherRequestScheduler.cs</a></p>

<div class="highlight highlight-source-cs"><pre><span class="pl-c">// Read list of cities</span>
<span class="pl-k">var</span> cities = (<span class="pl-k">await</span> GetCityList()).Select(c =&gt; c.Name);

<span class="pl-c">// Create initial message with CorrelationId assigned to it</span>
<span class="pl-k">var</span> message = Message.CreateFlowStartMessage(<span class="pl-k">new</span> RequestWeatherHighlightsMessage
                                             {
                                                 Cities = cities
                                             });
message.TraceOptions = MessageTraceOptions.Routing;

<span class="pl-c">// Define callback with result message</span>
<span class="pl-k">var</span> callback = CallbackPoint.Create&lt;WeatherHighlightsMessage&gt;();

<span class="pl-c">// Send message into actors network and specify wait timeout</span>
<span class="pl-k">var</span> promise = messageHub.EnqueueRequest(message, callback, TimeSpan.FromMinutes(<span class="pl-c1">1</span>));

<span class="pl-c">// Wait for result</span>
<span class="pl-k">var</span> weatherAggregates = (<span class="pl-k">await</span> promise.GetResponse()).GetPayload&lt;WeatherHighlightsMessage&gt;();

<span class="pl-c">// Print result</span>
WriteLine($<span class="pl-s"><span class="pl-pds">"</span>Lowest T: {weatherAggregates.LowestTemperature.CityName} {weatherAggregates.LowestTemperature.Temperature} C <span class="pl-pds">"</span></span> +
          $<span class="pl-s"><span class="pl-pds">"</span>Highest T: {weatherAggregates.HighestTemperature.CityName} {weatherAggregates.HighestTemperature.Temperature} C. <span class="pl-pds">"</span></span>);
</pre></div>

<h3>
<a id="sample-message-declaration" class="anchor" href="#sample-message-declaration" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sample Message declaration</h3>

<div class="highlight highlight-source-cs"><pre>[ProtoContract]
<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">RequestWeatherHighlightsMessage</span>: <span class="pl-k">Payload</span>
{
    <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-k">byte</span>[] MessageIdentity = <span class="pl-s"><span class="pl-pds">"</span>REQWHIGHLT<span class="pl-pds">"</span></span>.GetBytes();
    <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-k">byte</span>[] MessageVersion = <span class="pl-s"><span class="pl-pds">"</span>1.0<span class="pl-pds">"</span></span>.GetBytes();

    [ProtoMember(<span class="pl-c1">1</span>)]
    <span class="pl-k">public</span> IEnumerable&lt;<span class="pl-k">string</span>&gt; <span class="pl-en">Cities</span> { <span class="pl-k">get</span>; <span class="pl-k">set</span>; }

    <span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-k">byte</span>[] Version =&gt; MessageVersion;
    <span class="pl-k">public</span> <span class="pl-k">override</span> <span class="pl-k">byte</span>[] Identity =&gt; MessageIdentity;
}</pre></div>

<p>Default serializer for all messages, other than Exception, <a href="https://github.com/mgravell/protobuf-net">protobuf-net</a>.</p>

<h2>
<a id="actor" class="anchor" href="#actor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Actor</h2>

<p>Here is the code for one of the actors, responsible for getting current weather in a city:</p>

<div class="highlight highlight-source-cs"><pre><span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">WeatherCollector</span> : <span class="pl-k">IActor</span>
{
    <span class="pl-c">// Method, which handles RequestCityWeatherMessage message</span>
    [MessageHandlerDefinition(typeof (RequestCityWeatherMessage))]
    <span class="pl-k">private</span> <span class="pl-k">async</span> Task&lt;IActorResult&gt; <span class="pl-en">Handler</span>(<span class="pl-k">IMessage</span> <span class="pl-smi">message</span>)
    {
        <span class="pl-c">// Get message payload</span>
        <span class="pl-k">var</span> request = message.GetPayload&lt;RequestCityWeatherMessage&gt;();

        <span class="pl-c">// Request weather from external service and wait for result</span>
        <span class="pl-k">var</span> weather = <span class="pl-k">await</span> GetCityWeather(request.CityName);        
        <span class="pl-k">var</span> cityWeather = <span class="pl-k">new</span> CityWeather
                          {
                              CityName = request.CityName,
                              Temperature = weather?.Main?.Temp
                          };

        <span class="pl-c">// Create CityWeatherMessage message with current weather in the city</span>
        <span class="pl-c">// Forward TotalCityCount to the next actor</span>
        <span class="pl-k">var</span> response = Message.Create(<span class="pl-k">new</span> CityWeatherMessage
                                      {
                                          Weather = cityWeather,
                                          TotalCityCount = request.TotalCityCount
                                      });

        <span class="pl-c">// Create a message to be processed by a logging actor</span>
        <span class="pl-k">var</span> log = Message.Create(<span class="pl-k">new</span> LogCityWeatherMessage
                                 {
                                     Weather = cityWeather
                                 });

        <span class="pl-c">// Return response messages</span>
        <span class="pl-k">return</span> <span class="pl-k">new</span> ActorResult(response, log);
    }
}</pre></div>

<p>Complete solution for Weather example could be found <a href="https://github.com/iiwaasnet/weather">here</a>.
Another example, which uses Rendezvous service, could be found in <a href="https://github.com/iiwaasnet/kino/tree/master/src/Samples">Samples</a> folder.</p>

<p>Powered by <strong><a href="https://github.com/zeromq/netmq">NetMQ</a></strong></p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/iiwaasnet/kino">Kino</a> is maintained by <a href="https://github.com/iiwaasnet">iiwaasnet</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
